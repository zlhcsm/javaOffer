# Redis面试题汇总
[参考知乎用户：TD李](https://zhuanlan.zhihu.com/p/57473266)  
[参考知乎用户：优知学院](https://zhuanlan.zhihu.com/p/58333436)  
[参考知乎用户：java架构交流](https://zhuanlan.zhihu.com/p/55380579)  
[参考知乎用户：动力节点](https://zhuanlan.zhihu.com/p/79778696)   
[以后添加内容：Redis底层实现z](https://zhuanlan.zhihu.com/p/84274006 )

### Redis基础相关问题
#### Redis 是什么？
>Redis(Remote DIctionary Server) 是完全开源/c实现/高性能/基于内存的key-value数据库。
#### 说说它的优点和缺点？
`优势：`
- 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
- 支持丰富数据类型，支持string，list，set，sorted set，hash
- 支持事务，这里的事务是指：服务器不会中断事务去执行其他命令，而是在事务的所有命令执行完毕后再执行其他命令！并不保证回滚。
- 丰富的特性：可用于缓存，消息publish/subscribe，按key设置过期时间，过期后将会自动删除，持久化
#### Redis的读写性能如何啊？
单点TPS达到8万/秒，QPS达到10万/秒。
>贴士说明：1.QPS: 应用系统每秒钟最大能接受的用户访问量  
      每秒钟处理完请求的次数，注意这里是处理完，具体是指发出请求到服务器处理完成功返回结果。可以理解在server中有个counter，每处理一个请求加1，1秒后counter=QPS。

>2.TPS： 每秒钟最大能处理的请求数
 每秒钟处理完的事务次数，一个应用系统1s能完成多少事务处理，一个事务在分布式处理中，可能会对应多个请求，对于衡量单个接口服务的处理能力，用QPS比较合理。
 
#### Redis主要有哪些功能？
- 1.哨兵（Sentinel）和复制（Replication
Redis服务器毫无征兆的罢工是个麻烦事，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要哨兵和复制。  
哨兵Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能，Replication则是负责让一个Redis服务器可以配备多个备份的服务器。  
Redis也是利用这两个功能来保证Redis的高可用的。
- 2.事务
很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力，并保证其原子性。
- 3.LUA脚本
在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了。
- 4.持久化
redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。
- 5.集群
单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上，这也有点类似mysql数据库的主从同步。
在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的，
#### Redis有哪些适合的场景？
1）Session共享(单点登录)

2）页面缓存

3）队列

4）排行榜/计数器

5）发布/订阅
#### Redis与memcached相比有哪些优势？
- 1.memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型
- 2.Redis的速度比memcached快很多
- 3.Redis可以持久化其数据
- 4.Redis支持数据的备份，即master-slave模式的数据备份。
#### Redis支持哪几种数据类型？
支持多种类型的数据结构  

类型|说明|底层数据结构
---|---|---
字符串string|最基本的数据类型，二进制安全的字符串，最大512M。|int和raw
列表list |按照添加顺序保持顺序的字符串列表。|ziplist、linkedlist和quicklist默认quickList
集合set|无序的字符串集合，不存在重复的元素。|intset和hashtable
有序集合sorted set|已排序的字符串集合。|ziplist和skiplist
hash|key-value对的一种集合。|ziplist和hashtable
#### Redis主要消耗什么物理资源？
内存
#### Redis有哪几种数据淘汰策略？
在Redis中，允许用户设置最大使用内存大小server.maxmemory，当Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。
- 1.volatile-lru:从已设置过期的数据集中挑选最近最少使用的淘汰
- 2.volatile-ttr:从已设置过期的数据集中挑选将要过期的数据淘汰
- 3.volatile-random:从已设置过期的数据集中任意挑选数据淘汰
- 4.allkeys-lru:从数据集中挑选最近最少使用的数据淘汰
- 5.allkeys-random:从数据集中任意挑选数据淘汰
- 6.noenviction:禁止淘汰数据
redis淘汰数据时还会同步到aof  
注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。
#### 策略规则？
1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru

2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random
#### Redis官方为什么不提供Windows版本？
#### 一个字符串类型的值能存储最大容量是多少？
512M
#### 如何将 Redis 放到应用程序中？
#### 使用 Redis 的时候应用程序是如何进行读写的？
#### 为什么Redis需要把所有数据放到内存中？
Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。
#### Redis是单进程单线程的？
>Redis是单进程单线程的，Redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。
#### Redis为什么是单线程的？
多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。因为CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存或者网络带宽。单线程无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来解决。
#### Redis过期键的删除策略
1、定时删除:在设置键的过期时间的同时，创建一个定时器timer). 让定时器在键的过期时间来临时，立即执行对键的删除操作。

2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。

3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。
#### Redis的同步机制了解么？
Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。


### Redis集群相关问题
#### Redis集群方案应该怎么做？都有哪些方案？
- 1.twemproxy
- 2.codis，目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。
- 3.Redis cluster3.0自带的集，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。
#### 集群的原理是什么？
1)、Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

2)、Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
#### MRedis集群方案什么情况下会导致整个集群不可用？
有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。
#### Redis和Redisson有什么关系？
#### jedis与Redisson对比有什么优缺点？
#### 说Redis哈希槽的概念？
Redis集群没有使用一致性hash,而是引入了哈希槽的概念，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。
#### Redis集群的主从复制模型是怎样的？
为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.
#### Redis集群会有写操作丢失吗？为什么？
Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。
#### Redis集群之间是如何复制的？
>异步复制
#### Redis集群最大节点个数是多少？
Redis集群预分好`16384`个桶(哈希槽)


#### Redis分布式锁等相关问题
#### 使用过Redis分布式锁么，它是怎么实现的？
先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放
#### 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的
#### 简述Redis分布式锁的缺陷？
#### 讲讲对Redisson实现Redis分布式锁的底层原理的理解？
#### 加锁机制，锁互斥机制，watch dog自动延期机制，可重入加锁机制，锁释放机制是什么？
#### Redis 的 Setnx 命令是如何实现分布式锁的？
#### 说说对Setnx 的实现锁的原理的理解？
#### 如何避免死锁的出现？
#### 怎么理解Redis事务？
1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。


#### 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？

### Redis结合MySQL 的相关问题
#### Redis 如何与 MySQL 数据库结合起来？
#### 应用通过 Redis 客户端进行读取并展示，是所有的数据都是这么做吗？
#### 在修改数据的时候是修改到 Redis 吗？还是直接修改 MySQL?
#### 如果修改 Redis 中数据，那什么时候同步到 MySQL，是被迫的，还是开发人

### Redis优化问题
#### Redis如何做内存优化？
尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.
#### 都有哪些办法可以降低Redis的内存使用情况呢？
如果你使用的是32位的Redis实例，可以好好利用Hash,list,sorted set,set等集合类型数据，因为通常情况下很多小的Key-Value可以用更紧凑的方式存放到一起。
#### Redis常见性能问题和解决方案？
(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件  
(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次  
(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内  
(4) 尽量避免在压力很大的主库上增加从库  
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...  
这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变
#### 管道（Pipeline）有什么好处，为什么要用pipeline？
可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目

### Redis实用知识
#### Redis如何设置密码及验证密码？
设置密码：config set requirepass 123456  
授权密码：auth 123456
#### Redis集群如何选择数据库？
Redis集群目前无法做数据库选择，默认在0数据库
#### 怎么测试Redis的连通性？
使用`ping`命令
#### Redis事务相关的命令有哪几个？
> MULTI、EXEC、DISCARD、WATCH
#### Redis key的过期时间和永久有效分别怎么设置？
EXPIRE和PERSIST命令。

#### Redis的内存用完了会发生什么?
如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。
#### 一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？
理论上Redis可以处理多达2^32的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。任何list、set、和sorted set都可以放2^32个元素。换句话说，Redis的存储极限是系统中的可用内存值。
#### MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
Redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。
#### 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。
#### 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题
redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
#### 如果有大量的key需要设置同一时间过期，一般需要注意什么？
如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。
#### 使用过Redis做异步队列么，你是怎么用的？有什么缺点？
一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
#### 追问：可不可以用sleep呢？
list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
#### 追问：pub/sub有什么缺点？
在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RabbitMQ等。
#### 追问：redis如何实现延时队列？
使用`sortedset`，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理
#### 怎么配置AOF的写入时间？
有`appendfsync`配置项来决定：  
- always：每次写命令都会同步到aof文件
- everysec：每秒同步一次（默认）
- no：不主动进行同步，何时同步由操作系统决定
#### 怎么配置RDB的拷贝时间？
>save 900 1
 save 300 10
 save 60 10000
 
 以上配置表示当900s内有一次更新操作，或者300s内有10次更新操作，或者60s内有10000次更新操作，就会触发RDB持久化。

### Redis常见问题

### 其他知识
#### Redis支持的Java客户端都有哪些？官方推荐用哪个？
Redisson、Jedis、lettuce等等，官方推荐使用Redisson。
#### Jedis与Redisson对比有什么优缺点？
Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。
#### Nginx和Memcached采用的模型
`Nginx`：多进程单线程模型
`Memcached`：单进程多线程模型
#### Redis回收进程如何工作的？
一个客户端运行了新的命令，添加了新的数据。

Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。
#### Redis回收使用的是什么算法？
LRU算法 Random
#### Redis读写分离模型
通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。   
读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。
#### Redis数据分片模型
为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。  
可以将每个节点看成都是独立的master，然后通过业务实现数据分片。  
结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。
#### Redis提供了哪几种持久化方式？
- RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储
- AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以Redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.
如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.  
你也可以同时开启两种持久化方式, 在这种情况下, 当Redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.  
#### 如何选择合适的持久化方式？
>RDB（Redis DataBas）

默认开启，会按照配置的指定时间将内存中的数据快照到磁盘中，创建一个dump.rdb文件，Redis启动时再恢复到内存中。  
Redis会单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。  
需要注意的是，每次快照持久化都会将主进程的数据库数据复制一遍，导致内存开销加倍，若此时内存不足，则会阻塞服务器运行，直到复制结束释放内存；都会将内存数据完整写入磁盘一次，所以如果数据量大的话，而且写操作频繁，必然会引起大量的磁盘I/O操作，严重影响性能，并且最后一次持久化后的数据可能会丢失

>AOF 

以日志的形式记录每个写操作（读操作不记录），只需追加文件但不可以改写文件，Redis启动时会根据日志从头到尾全部执行一遍以完成数据的恢复工作。包括flushDB也会执行。



主要有两种方式触发：有写操作就写、每秒定时写（也会丢数据）。



因为AOF采用追加的方式，所以文件会越来越大，针对这个问题，新增了重写机制，就是当日志文件大到一定程度的时候，会fork出一条新进程来遍历进程内存中的数据，每条记录对应一条set语句，写到临时文件中，然后再替换到旧的日志文件（类似rdb的操作方式）。默认触发是当aof文件大小是上次重写后大小的一倍且文件大于64M时触发。

    当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。一般情况下，只要使用默认开启的RDB即可，因为相对于AOF，RDB便于进行数据库备份，并且恢复数据集的速度也要快很多。
    开启持久化缓存机制，对性能会有一定的影响，特别是当设置的内存满了的时候，更是下降到几百reqs/s。所以如果只是用来做缓存的话，可以关掉持久化。                
#### RDB和AOF对比
属性 | RDB | AOF
---|--- |---
文件大小| 小 | 大
恢复速度| 快 | 慢
数据安全性 | 低 | 高
误操作修改| 不可以 | 可以(在rewrite前可删除命令)
#### 有2个命令用于生成RDB文件，save和bgsave命令区别
前者会阻塞Redis服务器进程，直到RDB文件创建完成为止；后者会fork一个子进程，然后由子进程来负责创建RDB文件，而父进程可以继续处理请求命令。
#### 数据库还原的情况是什么样的？
RDB文件的启动是在Redis服务器启动时自动执行的，所以Redis未提供用于加载RDB文件的命令。
注意：因为AOF文件的更新频率通常比RDB文件要高，所以如果Redis开启了AOF功能，则会优先使用AOF文件来还原数据；只有在AOF未开启情况下，Redis才会使用RDB文件完成数据库还原操作。
#### AOF文件备份期间，如果有新写入的操作怎么办？
写入时是异步，因此服务不会受影响。但为了AOF文件的一致性，选择写入到缓冲区中，等子进程在子进程执行完AOF重写后，会向父进程发送一个信号，然后父进程会进行以下操作：
- 将AOF重写缓冲区内容写入到新的AOF文件中，这是新的AOF文件所保存的数据库状态和服务器当前状态一致。
- 对新的AOF文件更改名字，原子覆盖现有的AOF文件，完成新旧两个文件的替换。
#### Redis如何做持久化？
bgsave做镜像全量持久化，aof做增量持久化。

因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。

在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。

#### 追问：如果突然机器停电怎么办？
取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。

但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。
#### 追问：bgsave的原理是什么？
fork和cow  
fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来
#### 混合持久化了解么？说一下
既然有AOF和RDB两种方式，那么哪一种更好呢？总的来说，二者都有优缺点，最好是根据业务场景来做（只作为缓存的场景理论上也可以不要持久化策略），同样的数据集AOF文件要比RDB文件大很多，但是AOF策略数据持久化更实时可靠一些。因为二者各有所长，所以Redis4.0中引入了混合持久化机制。  
在Redis 4.0 中引入了混合持久化，将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。
![](https://pic2.zhimg.com/80/v2-7600d670067663ac5e9df2ef97b335ad_hd.jpg)
于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升

                         
                
                
                
                
                
                
                
                
                           
                           

































